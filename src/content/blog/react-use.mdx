---
title: "React `use`"
description: "Playing around with React's `use`"
pubDate: "August 17 2024"
---

<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
/>

import UseIdChangingExample from "../../components/blog/mui-autocomplete-transition/examples/UseIdChangingExample.jsx";
import AppSuspenseWithFlavorSuspenseExample from "../../components/blog/mui-autocomplete-transition/examples/AppSuspenseWithFlavorSuspenseExample.jsx";
import StartTransitionLoadingTextExample from "../../components/blog/mui-autocomplete-transition/examples/StartTransitionLoadingTextExample.jsx";
import NoUnmountEffectExample from "../../components/blog/mui-autocomplete-transition/examples/NoUnmountEffectExample.tsx";

## Outline

1. introduce use
1. gotcha with unmount

Another best practice utilizing `use` is to not use a promise that is created on
the client.
[Here is what the React docs have to say about that](https://react.dev/reference/react/use#caveats):

> Prefer creating Promises in Server Components and passing them to Client
> Components over creating Promises in Client Components. Promises created in
> Client Components are recreated on every render. Promises passed from a Server
> Component to a Client Component are stable across re-renders.

I believe that this could be one of the biggests hurdles to widespread adoption
of `use`.

There are ways to easily create memoized promises on the client. Pass in an ID
to the component, and use that to track your promise in a `Map`. When that ID
changes, remove that promise from the cache. React's `useId` could help you here
with this. Wait. That is problematic too.

<UseIdChangingExample client:only="react" />

The example above is console.logging `useId`'s result twice. Once before `use`
and then right `use`. When the app initiates a loading Transition, the first
console.log runs. The second does not. When the the loading Transition
completes, both console.logs run.

This is different behavior then I have come to expect from a React component.
Hooks were different from class components, and I adjusted. `use` is different,
and I will adjust. These aspects of React 19 are currently in canary release so
it all subject to change. Until React 19's API settles down, and the devrel
folks make the rounds, helping us all to understand how to better use these new
paradigms, I can only speculate at how React 19 will effect us in userland.

One interesting caveat about `use` and client components is that if your
component unmounts before `use` has resolved, your "unmount" effect in the
component that utilizes `use` will not run.

Below is an example of an app that takes 5 seconds to load. Take the following
steps to see the "unmount" effect running:

- open your browser dev-tools
- press the load button
- Wait 5 seconds for the "Success!" message to show up
- press the "Unmount" button
- observe the "unmount" message in the console

Once that is done, do the following to see the "unmount" effect not running:

- press the load button
- before the 5 seconds are up, press the "Unmount" button
- observe how the "unmount" message does not show up in the console

<NoUnmountEffectExample client:only="react" />

The `<AppLoading>` component is a child of `<Suspense>`. When `<AppLoading>`
mounts, it calls `use`. This tells the parent component that a pending
Transition has happened, and `<Suspense>` should show the loading state provided
by the `fallback` prop. When you press the "Unmount" button, it is removing the
both the `<Suspense>` and all of its children. Since `<AppLoading>` triggered a
Transition, and `<Suspense>` was showing the fallback, maybe `<AppLoading>` was
never mounted in such a state to call the `useEffect` that has the unmounting
behavior in it...?

This is paradigm-changing behavior for me.

With `<Suspense>` wrapped around the flavor select:

<AppSuspenseWithFlavorSuspenseExample client:only="react" />

We are able to get it to work, but only after the first. Maybe conditional usage
of `use`?

<StartTransitionLoadingTextExample client:only="react" />
